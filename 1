from parser import parser
from lark import Tree, Token

import re
import subprocess

debug = False

var_count_ = 0
def var_count():
  global var_count_
  var_count_ += 1
  return var_count_

def new_var():
  return "_var_%d" % var_count()

def compile_number(code, value):
  code += "_stack:push(%s)\n" % value
  return code

def compile_string(code, value):
  code += "_stack:push({_str = true, %s})\n" % ", ".join(["\"%s\"" % c for c in value[1:-1]])
  return code

def compile_character(code, value):
  code += "_stack:push(%s)\n" % value
  return code


def compile_macro(code, name, splice, body):
  code += "function %s(%s)\n" % (name, splice.children[0])
  code = compile_tree(code, body)
  code += "end\n"
  return code

def compile_combinator(code, operators):
  if len(operators) == 1:
    return compile_tree(code, operators[0])
  if operators[0] == "$>":
    temp = new_var()
    code += "%s = {}\n" % temp
    a = new_var()
    i = new_var()
    x = new_var()
    code += "%s = _stack:pop()\n" % a
    code += "for %s, %s in pairs(%s) do\n" % (i, x, a)
    code += "_stack:push(%s)\n" % x
    code = compile_combinator(code, operators[1:])
    code += "table.insert(%s, 0, _stack:pop())\n" % (temp)
    code += "end\n"
    code += "_stack:push(_clone(%s))\n" % temp
  elif operators[0] == "&>":
    temp = new_var()
    code += "%s = {}\n" % temp
    a = new_var()
    x = new_var()
    code += "%s = _stack:pop()\n" % a
    code += "for _, %s in pairs(%s) do\n" % (x, a)
    code += "_stack:push(%s)\n" % x
    code = compile_combinator(code, operators[1:])
    code += "if _stack:pop() ~= 0 then\n"
    code += "table.insert(%s, %s)\n" % (temp, x)
    code += "end\n"
    code += "end\n"
    code += "_stack:push(%s)\n" % temp

  elif operators[0] == "<>":
    temp = new_var()
    a = new_var()
    x = new_var()
    code += "%s = _stack:pop()\n" % a
    code += "%s = nil\n" % temp
    code += "for _, %s in pairs(%s) do\n" % (x, a)
    code += "if not %s then\n" % temp
    code += "%s = %s\n" % (temp, x)
    code += "else\n"
    code += "_stack:push(%s)\n" % temp
    code += "_stack:push(%s)\n" % x
    code = compile_combinator(code, operators[1:])
    code += "%s = _stack:pop()\n" % temp
    code += "end\n"
    code += "end\n"
    code += "_stack:push(%s)\n" % temp
  else:
    ops = "_flatten("
    i = -1
    for i, o in enumerate(operators[1:]):
      if isinstance(o, Tree) and o.data == "splice":
        ops += o.children[0]
      else:
        if i >= len(operators[1:]) - 1:
          if i == 0: i = -1
          break
        ops += "{" + o + "}"
      ops += ", "
    ops = ops[:-2] + ")"
    if i < 0:
      ops = "{}"
    code += "%s(%s)\n" % (operators[0], ops)
  return code

def compile_operator(code, value):

  if value in ["+", "-", "*", "/", "^", "%"]:
    code += "-- %s --\n" % value
    code += "a = _stack:pop()\n"
    code += "b = _stack:pop()\n"
    code += "_stack:push(b %s a)\n" % value
  elif value == "^-":
    code += "-- unary minus (^-) --\n"
    code += "a = _stack:pop()\n"
    code += "_stack:push(-a)\n"
  elif value == "#":
    code += "-- length (#) --\n"
    code += "a = _stack:pop()\n"
    code += "_stack:push(#a)\n"
  elif value == "=":
    code += "-- equals (=) --\n"
    code += "a = _stack:pop()\n"
    code += "b = _stack:pop()\n"
    code += "_stack:push(b == a and 1 or 0)\n"
  elif value == "/=":
    code += "a = _stack:pop()\n"
    code += "b = _stack:pop()\n"
    code += "_stack:push(b ~= a and 1 or 0)\n"
  elif value in ["<", ">", "<=", ">="]:
    code += "-- %s --\n" % value
    code += "a = _stack:pop()\n"
    code += "b = _stack:pop()\n"
    code += "_stack:push(b %s a and 1 or 0)\n" % value
  elif value == "|<":
    code += "-- dump (|<) --\n"
    code += "a = _stack:pop()\n"
    code += "print(_repr(a))\n"
  elif value == ".":
    code += "-- dup (.) --\n"
    code += "a = _stack:pop()\n"
    code += "_stack:push(a)\n"
    code += "_stack:push(a)\n"
  elif value == "..":
    code += "-- double dup (..) --\n"
    code += "a = _stack:pop()\n"
    code += "b = _stack:pop()\n"
    code += "_stack:push(b)\n"
    code += "_stack:push(a)\n"
    code += "_stack:push(b)\n"
    code += "_stack:push(a)\n"
  elif value == "<|>":
    code += "-- flip (<|>) --\n"
    code += "a = _stack:pop()\n"
    code += "b = _stack:pop()\n"
    code += "_stack:push(a)\n"
    code += "_stack:push(b)\n"
  elif value == "++":
    code += "-- append (++) --\n"
    code += "a = _stack:pop()\n"
    code += "b = _stack:pop()\n"
    code += "c = _clone(b)\n"
    code += "for x = 1, #a do\n"
    code += "table.insert(c, a[x])\n"
    code += "end\n"
    code += "_stack:push(c)\n"
  elif value == "|+|":
    code += "-- max (|+|) --\n"
    code += "a = _stack:pop()\n"
    code += "b = _stack:pop()\n"
    code += "if a > b then\n"
    code += "_stack:push(a)\n"
    code += "else\n"
    code += "_stack:push(b)\n"
    code += "end\n"
  elif value == "?":
    code += "a = _stack:pop()\n"
    code += "_stack:push(_split(_repr(a)))\n"
  elif value == "!!":
    code += "-- index (!!) --\n"
    code += "a = _stack:pop()\n"
    code += "b = _stack:pop()\n"
    code += "_stack:push(b[a])\n"
  elif value == "/.":
    code += "-- head (/.) --\n"
    code += "a = _stack:pop()\n"
    code += "_stack:push(a[1])\n"
  elif value == "/@":
    code += "-- tail (/@) --\n"
    code += "a = _stack:pop()\n"
    code += "b = {}\n"
    code += "for i = 2, #a do\n"
    code += "table.insert(b, a[i])\n"
    code += "end\n"
    code += "_stack:push(b)\n"
  else:
    assert False, "Invalid operator: %s" % value
  return code

def compile_name(code, value):
  code += "%s()\n" % value
  return code

def compile_array(code, values):
  for val in values:
    code = compile_tree(code, val)
  code += "temp = {}\n"
  for i in range(len(values)):
    code += "temp[%d] = _stack:pop()\n" % (i + 1)
  code += "_stack:push(_clone(temp))\n"
  return code

def compile_symbol(code, value):
  marks = re.findall(r"&SYM_(\d+)&", code)
  mark = ""
  if marks:
    mark = "_%s" % marks[0][0]
  var = "_symb_%d%s" % (var_count(), mark)
  code += "%s = _stack:pop()\n" % var
  code += "%s = function()\n" % value
  code += "_stack:push(%s)\n" % var
  code += "end\n"
  return code

def compile_declaration(code, name, *values):
  code += "function %s()\n" % name
  code = "&SYM_%d&" % var_count() + code
  for val in values:
    code = compile_tree(code, val)
  code += "end\n"
  sym_marks = re.findall(r"&SYM_\d+&", code)
  code = code.replace(sym_marks[0], "")
  return code

def compile_expression(code, atoms):
  for a in atoms:
    code = compile_tree(code, a)
  return code

def compile_if(code, true):
  code += "if _stack:pop() ~= 0 then\n"
  code = compile_tree(code, true)
  code += "end\n"
  return code

def compile_ifelse(code, true, false):
  code += "if _stack:pop() ~= 0 then\n"
  code = compile_tree(code, true)
  code += "else\n"
  code = compile_tree(code, false)
  code += "end\n"
  return code

def compile_while(code, cond, body):
  code += "while true do\n"
  code = compile_tree(code, cond)
  code += "if _stack:pop() == 0 then\n"
  code += "break\n"
  code += "end\n"
  code = compile_tree(code, body)
  code += "end\n"
  return code

def compile_eval(code, atoms):
  for a in atoms:
    code = compile_tree(code, a)
  return code

def compile_program(code, args):
  *decls, expr = args
  for dec in decls:
    code = compile_tree(code, dec)
  code = compile_tree(code, expr)
  return code

def compile_tree(code, tree):
  if isinstance(tree, Token):
    if tree.type == "NUMBER":
      return compile_number(code, tree.value)
    if tree.type == "OPERATOR":
      return compile_operator(code, tree.value)
    if tree.type == "NAME":
      return compile_name(code, tree.value)
    if tree.type == "STRING":
      return compile_string(code, tree.value)
    if tree.type == "CHARACTER":
      return compile_character(code, tree.value)
  if tree.data == "symbol":
    return compile_symbol(code, *tree.children)
  if tree.data == "array":
    return compile_array(code, tree.children)
  if tree.data == "declaration":
    return compile_declaration(code, *tree.children)
  if tree.data == "expression":
    return compile_expression(code, tree.children)
  if tree.data == "eval":
    return compile_eval(code, tree.children)
  if tree.data == "program":
    return compile_program(code, tree.children)
  if tree.data == "paren":
    return compile_expression(code, tree.children)
  if tree.data == "combinator":
    return compile_combinator(code, tree.children)
  if tree.data == "macro":
    return compile_macro(code, *tree.children)
  if tree.data == "if":
    return compile_if(code, *tree.children)
  if tree.data == "ifelse":
    return compile_ifelse(code, *tree.children)
  if tree.data == "while":
    return compile_while(code, *tree.children)
  assert False, "Unimplemented: %s" % tree.data

def compile(code):
  code = re.sub(r";.+", "", code)
  with open("lib.grp") as f:
    grplib = f.read()
  tree = parser.parse(grplib + code)
  with open("lib.lua") as f:
    lib = f.read()
  result = compile_tree(lib, tree)
  with open("out.lua", "w") as f:
    f.write(result)
  subprocess.run(["luajit", "out.lua"])

with open("in.grp") as f:
  compile(f.read())
